import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.rmi.AlreadyBoundException;
import java.rmi.NotBoundException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Scanner;


public class Service_App {
	//estou um bocado confuso com as mensagens n percebi se é assim e depois junto numa string ou se pode ser tudo String 
	private static byte [] versionId={'1','.','0'};
	/* #TODO aldrabei para string pk perdi a paciencia
	private static byte[] CR ={'0','x','D'};
	private static byte[] LF={'0','x','A'};
	*/
	private static String metadatafile=".metadata";
	private static String CR="0xD";
	private static String LF="0xA";
	//will need to change senderId to be generated by SHA
	private static String senderId="Eu";
	public static void main(String[] args) throws AlreadyBoundException, IOException, NoSuchAlgorithmException {
		if(args.length==0){
			System.out.println("usage like:");
			System.out.println("java Service_App <portmc><mcaddress><portmdb><mdbaddress><BACKUP><filename><replicationDeg>");
			System.out.println("java Service_App <portmc><mcaddress><portmdr><mdraddress><RESTORE><filename>");
			return;
		}
		//inicialização das variaveis 
		
		//#TODO make this an arg
		
		

		
		
		if(args[4].equals("BACKUP") /*&& args.length==4*/ ){
			Backup(Integer.parseInt(args[6]),args[5],Integer.parseInt(args[0]),InetAddress.getByName(args[1]),Integer.parseInt(args[2]),InetAddress.getByName(args[3]));
			
		}

		
		if(args[4].equals("RESTORE") ){
			Restore(args[5],Integer.parseInt(args[0]),InetAddress.getByName(args[1]),Integer.parseInt(args[2]),InetAddress.getByName(args[3]));
					
		}
		//RESTORE 
		/*
		if(args[1].equals("DELETE")){
			//envio da mensagem para o grupo multicast
			//tratar a recepcção da resposta, o backup por exemplo tem que receber o numero de respostas iguais ao replication degree
			//Cria o objecto RMI para executar os subprotocols 
			//fazer igual para os ifs todos 

			stub=(RemoteInterface)UnicastRemoteObject.exportObject(app, 0);
			registry= LocateRegistry.getRegistry();
			registry.bind("Service", stub);
		}
		//DELETE
		if(args[1].equals("STATE")){
			//envio da mensagem para o grupo multicast
			//tratar a recepcção da resposta, o backup por exemplo tem que receber o numero de respostas iguais ao replication degree
			//Cria o objecto RMI para executar os subprotocols 
			//fazer igual para os ifs todos 

			stub=(RemoteInterface)UnicastRemoteObject.exportObject(app, 0);
			registry= LocateRegistry.getRegistry();
			registry.bind("Service", stub);
		}
		//Space allocation management
*/

	}
	
	public static void Restore(String filename,int mcport,InetAddress mcaddress,int mdrport,InetAddress mdraddress) throws NoSuchAlgorithmException, IOException {
		DatagramPacket packetsend;
		DatagramPacket packetreceive;
		
		byte [] FIleContent;
		String msgHeader = null;
		String msgBody=null;
		String answer=null;
		String msg=null;
		DatagramSocket socket = new DatagramSocket();
		int nTotalChunks = 0;
		byte[] buf=new byte[256];

		MessageDigest md =MessageDigest.getInstance("SHA-256");
		md.update(filename.getBytes());
		byte byteData[]=md.digest();
		
		//convert to hex
		StringBuffer filenamebuf = new StringBuffer();
		for (int i = 0; i < byteData.length; i++) {
			filenamebuf.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
		}
		int nChunks=0,answercount=0;
		
		final Scanner s = new Scanner(new File(metadatafile));
		while(s.hasNextLine()) {
			
		    final String line = s.nextLine();
		
		    if(line.split(" +")[0].equals(filenamebuf.toString())){
		    	nTotalChunks=Integer.parseInt(line.split(" ")[1]);
		    	}
		}
		s.close();
		
		
		while(answercount<nTotalChunks){
		
			msgHeader="GETCHUNK"+" "+versionId+" "+senderId+" "+ filenamebuf.toString()+" "+(nChunks+1) +" "+CR+LF+" ";
			buf=msgHeader.getBytes();
			
			packetsend = new DatagramPacket(buf, buf.length, mcaddress, mcport);
			socket.send(packetsend);
			
			socket.setSoTimeout(5000);
			try{
				
				buf=new byte[64*1000+msgHeader.getBytes().length];
				packetreceive = new DatagramPacket(buf, buf.length);
				//waits for reception or launches exception
				socket.receive(packetreceive);
				//when received shows the answer
				answer = new String(packetreceive.getData(), 0, packetreceive.getLength());
				//System.out.println(answer);
				
				answercount++;
				nChunks++;
			}
			catch (SocketTimeoutException e) {
				System.out.println("still missing "+(nTotalChunks-answercount)+" answers");
				System.out.println("re-sending");
				socket.send(packetsend);
				
			}
			
			
		}
	socket.close();
	}

	public static void writeMetadata(String filename, int nChunks) throws IOException {
		FileOutputStream file=new FileOutputStream(metadatafile,true);
		file.write((filename+" "+nChunks+"\n").getBytes());
		file.flush();
		file.close();
	}

	public static void Backup(int repDegree,String filename,int mcport,InetAddress mcaddress,int mdbport,InetAddress mdbaddress) throws NoSuchAlgorithmException, IOException{
		
		MessageDigest md =MessageDigest.getInstance("SHA-256");
		md.update(filename.getBytes());
		byte byteData[]=md.digest();
		int answerCount=0;
		//convert to hex
		StringBuffer filenamebuf = new StringBuffer();
		for (int i = 0; i < byteData.length; i++) {
			filenamebuf.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
		}

		//envio da mensagem para o grupo multicast
		//filename=args[2]

		RemoteInterface stub=null;
		Registry registry=null;
		DatagramSocket socket = new DatagramSocket();


		byte[] buf;

		DatagramPacket packetsend;
		DatagramPacket packetreceive;

		String msgHeader = null;
		String msgBody=null;
		String answer=null;
		String msg=null;
		File inputFile = new File(filename);

		FileInputStream inputStream;

		int fileSize = (int) inputFile.length();

		int nChunks = 0, read = 0, readLength=64*1000, totalChunks=0;
		byte[] byteChunkPart;
		
		totalChunks = fileSize/readLength;
		if(fileSize%readLength != 0)
			totalChunks++;;
		writeMetadata(filenamebuf.toString(),totalChunks);

		try {

			inputStream = new FileInputStream(inputFile);

			while (fileSize > 0) {

				if (fileSize <=readLength ) {

					readLength = fileSize;

				}
				byteChunkPart = new byte[readLength];

				read = inputStream.read(byteChunkPart, 0, readLength);

				fileSize -= read;

				assert (read == byteChunkPart.length);

				nChunks++;
				
				msgHeader="PUTCHUNK"+" "+versionId+" "+senderId+" "+ filenamebuf.toString()+" "+nChunks +" "+repDegree +" "+CR+LF+" ";
				
				msgBody=new String(byteChunkPart);
				msg=msgHeader+msgBody;
				
				buf=new byte[msgHeader.getBytes().length+byteChunkPart.length];
				System.arraycopy(msgHeader.getBytes(), 0, buf, 0, msgHeader.getBytes().length);
				System.arraycopy(byteChunkPart, 0, buf, msgHeader.getBytes().length, byteChunkPart.length);
				//System.out.println(msg);
				//System.out.println("Buffer");
				
				//buf=msg.getBytes();
				System.out.println(buf);
				//first message gets sent to multicastgroup
				packetsend = new DatagramPacket(buf, buf.length, mdbaddress, mdbport);

				socket.send(packetsend);
				
				//waits for response of peers and the number of responses must be equal to repdegree or gets re-sent
				//#TODO test with more peers and bigger repdegree than 1 so see if there is an issue around all peers answering at same time :o
				while(answerCount<repDegree){
					//Timeout so it re-sends 
					socket.setSoTimeout(5000);
					try{
					//cleans up buffer
					buf=new byte[256];
					packetreceive = new DatagramPacket(buf, buf.length);
					//waits for reception or launches exception
					socket.receive(packetreceive);
					//when received shows the answer
					answer = new String(packetreceive.getData(), 0, packetreceive.getLength());
					System.out.println(answer);
					answerCount++;
					try {
						Thread.sleep(4000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					//on reception uses that packet's sender address to make the remote method of savin the chunk
					registry = LocateRegistry.getRegistry(packetreceive.getAddress().getHostName());
			        stub=(RemoteInterface)registry.lookup("Teste2");
			        //
			        stub.StoreBackupProtocol(filenamebuf.toString(), nChunks, byteChunkPart);
					
					}
					catch (SocketTimeoutException e) {
						System.out.println("still missing "+(repDegree-answerCount)+" answers");
						System.out.println("re-sending");
						socket.send(packetsend);
						
					} catch (NotBoundException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
				}
				
				byteChunkPart = null;
				answerCount=0;
				
			}
			inputStream.close();
			
		} catch (IOException exception) {

			exception.printStackTrace();

		}

		
		//tratar a recepcção da resposta, o backup por exemplo tem que receber o numero de respostas iguais ao replication degree
		//Cria o objecto RMI para executar os subprotocols 
		//fazer igual para os ifs todos 

		
		
		socket.close();
		
	}

}
